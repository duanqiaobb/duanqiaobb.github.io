<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink"><description><title-info /><document-info><program-used>pandoc</program-used></document-info></description><body><title><p /></title><annotation><p></p></annotation><section><title><p>&lt;div style=&quot;color:#369&quot;&gt;今日计划&lt;/div&gt;</p></title><p>• 30前将普通傅里叶变化的算法和web程序写出来以及论文弄好(还有4天)</p><p>• 有道口语一课（切记）</p></section><section><title><p>&lt;div style=&quot;color:#369&quot;&gt;今日收获&lt;/div&gt;</p></title><section><title><p>C语言中的复数操作</p></title><p>复数在数学运算中十分重要，在编写数值运算或者算法的时候，我们会用到复数这种概念。 那么，复数在C/C++语言中是如何表示的呢？我们接下来一一介绍。</p><p>• C语言中复数<empty-line />在数学中一个复数可以定义为 <code>z=a + bi</code> 的形式。 <code>C</code> 语言在 <code>ISO C99</code> 时就引入了复数类型。它是通过 <code>complex.h</code> 中定义的。</p><p>我们可以使用 <code>complex</code> , <code>__complex__</code> , 或 <code>_ComplexI</code> 类型符号来表示。在C语言中有三种复数类型，分别为 <code>float complex</code> , <code>double complex</code> , <code>long double complex</code> 。他们之间 的区别就是表示复数中实部和虚步的数的数据类型不同。 <code>complex</code> 其实就是一个数组，数组中有两个元素，一个表示复数的实部，一个表示复数的虚部。</p><p>• 定义一个复数<empty-line />在 <code>complex.h</code> 头文件中定义了两个宏 <code>_Complex_I</code> 和 <code>I</code> 来创建一个复数。<empty-line /></p><empty-line /><p><code>Macro: const float complex _Complex_I;</code></p><p><code>Macro: const float complex  I;</code></p><empty-line /><p>这两个宏表示复数 <code>0+1i</code> , 我们可是使用这个单位复数来创建任何复数。</p><empty-line /><p><code></code></p><p><code>#include &lt;stdio.h&gt;</code></p><p><code>#include &lt;complex.h&gt;</code></p><p><code></code></p><p><code>int main(int argc, char *argv[])</code></p><p><code>{</code></p><p><code>  complex  double  a = 3.0 + 4.0 * _Complex_I;</code></p><p><code>  __complex__ double b = 4.0 + 5.0 * _Complex_I;</code></p><p><code>  _Complex  double c = 5.0 + 6.0 * _Complex_I;</code></p><p><code></code></p><p><code>  printf(&quot;a=%f+%fi\n&quot;, creal(a),cimag(a));</code></p><p><code>  printf(&quot;b=%f+%fi\n&quot;, creal(b), cimag(b));</code></p><p><code>  printf(&quot;c=%f+%fi\n&quot;, creal(c), cimag(c));</code></p><p><code></code></p><p><code></code></p><p><code></code></p><p><code>  printf(&quot;the arg of a is %d&quot;, carg(a));</code></p><p><code></code></p><p><code>  return 0;</code></p><p><code>}</code></p><empty-line /><p>• 复数的基本操作函数<empty-line />在 <code>complex.h</code> 头文件中定义一些对复数的基本操作的函数。<empty-line /></p><table><tr><th align="left">函数</th><th align="left">功能</th></tr><tr><td align="left">creal</td><td align="left">获取复数的实部</td></tr><tr><td align="left">cimag</td><td align="left">获取复数的虚部</td></tr><tr><td align="left">conj</td><td align="left">获取复数的共轭</td></tr><tr><td align="left">carg</td><td align="left">代表,复平面上穿过原点和复数在复平面表示的点,的直线和实数轴之间的夹角</td></tr><tr><td align="left">cproj</td><td align="left">返回复数在黎曼球面上的投影</td></tr></table><p><emphasis /></p><p>• 复数的数值操作<empty-line />复数类型也可以像普通数值类型， <code>int, double, long</code> 一样进行直接使用数值操作符号，进行数值操作。<empty-line /></p><empty-line /><p><code>#include &lt;stdio.h&gt;</code></p><p><code>#include &lt;complex.h&gt;</code></p><p><code></code></p><p><code>int main(int argc, char *argv[])</code></p><p><code>{</code></p><p><code>  complex  double  a = 3.0 + 4.0 * _Complex_I;</code></p><p><code>  __complex__ double b = 4.0 + 5.0 * _Complex_I;</code></p><p><code>  _Complex  double c = 5.0 + 6.0 * _Complex_I;</code></p><p><code></code></p><p><code>  complex double d =a + b;</code></p><p><code>  complex double f = a *b ;</code></p><p><code>  complex double g = a/b;</code></p><p><code></code></p><p><code>  printf (&quot;d=a+b=%f+%fi\n&quot;,creal(d),cimag(d));</code></p><p><code>  printf (&quot;f=a*b=%f+%fi\n&quot;,creal(f),cimag(f));</code></p><p><code>  printf(&quot;g=a/b=%f+%fi\n&quot;,creal(g),cimag(g));</code></p><p><code></code></p><p><code>  return 0;</code></p><p><code>}</code></p><empty-line /></section><section><title><p>C++中的复数</p></title><p>C++中的复数操作在C语言基础上引进了面向对象的特性，在 <code>C++</code> 头文件在 <code>complex</code> 中定义了一个 <code>complex</code> 类用来表示复数。同时为了兼容 <code>C</code> 的 <code>complex</code> 类型，也提供了一个 <code>complex.h</code> 的头文件。 不同的是，在 <code>complex.h</code> 头文件中， <code>complex</code> 关键字被废弃，只能使用 <code>_Complex</code> 和 <code>__complex__</code> 来使用 C风格的复数形式。</p><p>• 复数的定义<empty-line />在C++中可以使用两种方式定义一个复数，一个使用C风格 <code>_Complex</code> 和 <code>__complex__</code> ，一个是使用 <code>complex</code> 类。<empty-line /></p><empty-line /><p><code></code></p><p><code>#include &lt;iostream&gt;</code></p><p><code>#include &lt;complex&gt;</code></p><p><code>#include &lt;complex.h&gt;</code></p><p><code>using namespace std;</code></p><p><code>int main(int argc, char *argv[])</code></p><p><code>{</code></p><p><code>  complex&lt;double&gt; mycomplex(2.000,2);</code></p><p><code>  _Complex double  mycomplex2 = 2.000 + 3I;</code></p><p><code>  __complex__ double mycomplex3 = 2.000 + 4I;</code></p><p><code></code></p><p><code>  cout &lt;&lt; mycomplex &lt;&lt; endl;</code></p><p><code>  cout &lt;&lt; &quot;(&quot; &lt;&lt; creal(mycomplex2) &lt;&lt; &quot;,&quot; &lt;&lt; cimag(mycomplex2) &lt;&lt; &quot;)&quot; &lt;&lt; endl;</code></p><p><code>  cout &lt;&lt; &quot;(&quot; &lt;&lt; creal(mycomplex3) &lt;&lt; &quot;,&quot; &lt;&lt; cimag(mycomplex3) &lt;&lt; &quot;)&quot; &lt;&lt; endl;</code></p><p><code>  return 0;</code></p><p><code>}</code></p><empty-line /><p>• 复数的基本操作函数<empty-line />在C++中既可以使用 <code>C</code> 风格的相关函数。<empty-line /></p><table><tr><th align="left">函数</th><th align="left">功能</th></tr><tr><td align="left">creal</td><td align="left">获取复数的实部</td></tr><tr><td align="left">cimag</td><td align="left">获取复数的虚部</td></tr><tr><td align="left">conj</td><td align="left">获取复数的共轭</td></tr><tr><td align="left">carg</td><td align="left">获取,复平面上穿过原点和复数在复平面表示的点,的直线和实数轴之间的夹角</td></tr><tr><td align="left">cproj</td><td align="left">返回复数在黎曼球面上的投影</td></tr></table><p><emphasis /></p><p>也可以使用 <code>complex</code> 类中的相关操作方法。</p><table><tr><th align="left">方法</th><th align="left">功能</th></tr><tr><td align="left">complex.real()</td><td align="left">获取复数的实部</td></tr><tr><td align="left">complex.imag()</td><td align="left">获取复数的虚部</td></tr><tr><td align="left">complex.abs()</td><td align="left">获取复数的绝对值</td></tr><tr><td align="left">complex.arg()</td><td align="left">获取,复平面上穿过原点和复数在复平面表示的点,的直线和实数轴之间的夹角</td></tr><tr><td align="left">complex.norm()</td><td align="left">获取复数的范数</td></tr><tr><td align="left">complex.conj()</td><td align="left">获取复数的共轭</td></tr><tr><td align="left">complex.polar()</td><td align="left">获取极坐标对应的复数</td></tr><tr><td align="left">complex.proj()</td><td align="left">返回复数在黎曼球面上的投影</td></tr></table><p><emphasis /></p></section></section><section><title><p> &lt;div style=&quot;color:#369&quot;&gt;todo&lt;/div&gt;</p></title><p>• 详细了解cpp中的function-&gt;return type的用法</p><p>• 写一个管理markdown的博客vim插件(参考vim的vimwiki插件)</p><p>• 了解C++中的异常的使用</p><p>• 在emacs或者vim中实现一个小的智能程序</p><p>• 写一个类似Mac中的高亮当前鼠标位置的效果(Linux下)</p><p>• 在vim移植emacs的org-mode(针对markdown)</p><p>• 命令行的qq聊天(vim-plugin,emacs-plugin)</p><p>• 探究真正意义上的人工智能</p><p>• 学习黑客的思维</p><p>• 写个备份Gentoo Linux的脚本(Live版本,iso格式)</p><p>• 写个像Grammerly的功能的软件</p><p>• 写方面绑定手机的各种账号更换</p><p>• 看王垠的40行代码</p><p>• 学习scheme语言</p><p>• 详细看《Chapter 13. Copy contral》</p><p>• 详细看《 Chapter 12. Dynamic Memory》</p><p>• 详细看《13.1.4（p. 504）》</p><p>• 了解C++里面的lamda表达式</p><p>• C++的线程相关操作</p><p>• 看825页的dynamic<sub>cast</sub>(看完虚函数再看)</p><p>• 《 CPP prime 》 看到Circumventing the Virtual Mechanism</p><p>• grub,UEFI,Legacy,Windows Loader,以及其他相关加载器的相关知识</p></section><section><title><p> &lt;div style=&quot;color:#369&quot;&gt;明日计划&lt;/div&gt;</p></title></section></body></FictionBook>
